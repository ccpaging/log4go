package log4go

import (
	"fmt"
	"os"
	"io"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// These functions Compatibility with `log`

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed.
	// There is no control over the order they appear (the order listed
	// here) or the format they present (as described in the comments).
	// The prefix is followed by a colon only when Llongfile or Lshortfile
	// is specified.
	// For example, flags Ldate | Ltime (or LstdFlags) produce,
	//	2009/01/23 01:23:23 message
	// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
	//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

// `ConsoleLogWriter` defined in termlog.go
 
// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func NewOutLogWriter(out io.Writer, prefix string, flag int) *ConsoleLogWriter {
	c := &ConsoleLogWriter{
		out:	stdout,
		format: FORMAT_DEFAULT,
	}
	c.SetOutput(out)
	c.SetPrefix(prefix)
	c.SetFlags(flag)
	return c
}

// SetOutput sets the output destination for the logger. 
// Must be called before the first log message is written.
func (c *ConsoleLogWriter) SetOutput(w io.Writer) {
	c.out = w
}

// Compatibility with `log`
// SetFlags sets the output flags for the logger.
// Must be called before the first log message is written.
func (c *ConsoleLogWriter) SetFlags(flag int) {
	fmt := ""
	if flag&LUTC != 0 {
		// Not support
		fmt += ""
	}

	if flag&Ldate != 0 {
		fmt += "%D "
	}
	if flag&(Ltime|Lmicroseconds) != 0 {
		if flag&Lmicroseconds != 0 {
			// Not support
			fmt += "%T "
		} else {
			fmt += "%T "
		}
	}
	if flag&Llongfile != 0 {
		fmt += "%S "
	}
	if flag&Lshortfile != 0 {
		fmt += "%s "
	}

	c.format = fmt + "%M"
}

// SetPrefix sets the output prefix for the logger.
// Must be called before the first log message is written.
func (c *ConsoleLogWriter) SetPrefix(prefix string) {
	c.prefix = prefix
}

// Output writes the output for a logging event.
func (log Logger) CompatOutput(lvl Level, calldepth int, s string) {
	if log.skip(lvl) {
		return
	}

	// Determine caller func
	src := ""
	if calldepth >= 0 {
		pc, _, lineno, ok := runtime.Caller(calldepth)
		if ok {
			src = fmt.Sprintf("%s:%d", filepath.Base(runtime.FuncForPC(pc).Name()), lineno)
		}
	}

	// Make the log record
	rec := &LogRecord{
		Level:   lvl,
		Created: time.Now(),
		Source:  src,
		Message: strings.TrimRight(s, "\r\n"),
	}

	log.dispatch(rec)
}

// `Logger` defined in log4go.go

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
func (l Logger) Output(calldepth int, s string) error {
	l.CompatOutput(INFO, calldepth, s)
	return nil
}

// Printf calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Printf.
func (l Logger) Printf(format string, v ...interface{}) {
	l.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprintf(format, v...))
}

// Print calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Print.
func (l Logger) Print(v ...interface{}) {
 	l.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprint(v...))
}

// Println calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Println.
func (l Logger) Println(v ...interface{}) {
	l.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprintln(v...))
}

// Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
func (l Logger) Fatal(v ...interface{}) {
	l.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprint(v...))
	l.Close()
	os.Exit(1)
}

// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
func (l Logger) Fatalf(format string, v ...interface{}) {
	l.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprintf(format, v...))
	l.Close()
	os.Exit(1)
}

// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
func (l Logger) Fatalln(v ...interface{}) {
	l.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprintln(v...))
	l.Close()
	os.Exit(1)
}

// Panic is equivalent to l.Print() followed by a call to panic().
func (l Logger) Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	l.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	l.Close()
	panic(s)
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
func (l Logger) Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	l.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	l.Close()
	panic(s)
}

// Panicln is equivalent to l.Println() followed by a call to panic().
func (l Logger) Panicln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	l.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	l.Close()
	panic(s)
}

// `Global` logger defined in wrapper.go

// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func New(out io.Writer, prefix string, flag int) *Logger {
	return &Logger {
			"stdout": NewFilter(DEBUG, NewOutLogWriter(out, prefix, flag)),
		}
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
	if clw, ok := Global["stdout"].LogWriter.(*ConsoleLogWriter); ok {
		clw.SetOutput(w)
	}
}

// SetFlags sets the output flags for the standard logger.
func SetFlags(flag int) {
	if clw, ok := Global["stdout"].LogWriter.(*ConsoleLogWriter); ok {
		clw.SetFlags(flag)
	}
}

// SetPrefix sets the output prefix for the standard logger.
func SetPrefix(prefix string) {
	if clw, ok := Global["stdout"].LogWriter.(*ConsoleLogWriter); ok {
		clw.SetPrefix(prefix)
	}
}

// Write to the standard logger.

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is the count of the number of
// frames to skip when computing the file name and line number
// if Llongfile or Lshortfile is set; a value of 1 will print the details
// for the caller of Output.
func Output(calldepth int, s string) error {
	Global.CompatOutput(INFO, calldepth, s) // +1 for this frame.
	return nil
}

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Print.
func Print(v ...interface{}) {
	Global.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprint(v...))
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Printf.
func Printf(format string, v ...interface{}) {
	Global.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprintf(format, v...))
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Println.
func Println(v ...interface{}) {
	Global.CompatOutput(INFO, DefaultCallerSkip, fmt.Sprintln(v...))
}

// Fatal is equivalent to Print() followed by a call to os.Exit(1).
func Fatal(v ...interface{}) {
	Global.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprint(v...))
	Global.Close()
	os.Exit(1)
}

// Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	Global.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprintf(format, v...))
	Global.Close()
	os.Exit(1)
}

// Fatalln is equivalent to Println() followed by a call to os.Exit(1).
func Fatalln(v ...interface{}) {
	Global.CompatOutput(ERROR, DefaultCallerSkip, fmt.Sprintln(v...))
	Global.Close()
	os.Exit(1)
}

// Panic is equivalent to Print() followed by a call to panic().
func Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	Global.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	Global.Close()
	panic(s)
}

// Panicf is equivalent to Printf() followed by a call to panic().
func Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	Global.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	Global.Close()
	panic(s)
}

// Panicln is equivalent to Println() followed by a call to panic().
func Panicln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	Global.CompatOutput(CRITICAL, DefaultCallerSkip, s)
	Global.Close()
	panic(s)
}
